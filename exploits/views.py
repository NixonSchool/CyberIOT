import logging
from datetime import timedelta

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.db.models import Count, Sum
from django.db.models import Q, F
from django.db.models.functions import TruncDate
from django.http import HttpResponse, Http404
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, render, redirect
from django.template.loader import render_to_string
from django.urls import reverse
from django.utils import timezone
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import user_passes_test
from .decorators import admin_only_except_report
from .forms import VulnerabilityReportForm, VulnerabilityCommentForm, ExportRequestForm
from .models import Review, User, Vulnerability
from django.db.models import Avg

logger = logging.getLogger(__name__)


@require_http_methods(["GET", "POST"])
def report_vulnerability(request):
    if request.method == 'POST':
        form = VulnerabilityReportForm(request.POST, user=request.user)
        if form.is_valid():
            vulnerability = form.save(commit=False)
            if not form.cleaned_data['is_anonymous'] and request.user.is_authenticated:
                vulnerability.reported_by = request.user
            vulnerability.save()
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'redirect_url': reverse('exploits:vulnerability_list')
                })
            messages.success(request, 'Vulnerability report submitted successfully.')
            return redirect('exploits:vulnerability_list')
        else:
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                })
            messages.error(request, 'There was an error with your submission. Please check the form and try again.')
    else:
        form = VulnerabilityReportForm(user=request.user)
    return render(request, 'vulnerability_reporting/report_vulnerability.html', {'form': form})

@login_required
def vulnerability_list(request):
    vulnerabilities = Vulnerability.objects.all().order_by('-reported_at')
    paginator = Paginator(vulnerabilities, 30)  # Show 30 vulnerabilities per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    if request.method == 'POST':
        form = VulnerabilityCommentForm(request.POST)
        if form.is_valid():
            comment = form.save(commit=False)
            vulnerability_slug = request.POST.get('vulnerability_slug')
            comment.vulnerability = Vulnerability.objects.get(slug=vulnerability_slug)
            comment.user = request.user
            comment.save()
            messages.success(request, 'Comment added successfully.')
            return redirect('exploits:vulnerability_list')
        else:
            messages.error(request, 'Please correct the errors below.')
    else:
        form = VulnerabilityCommentForm()

    context = {
        'page_obj': page_obj,
        'comment_form': form
    }
    return render(request, 'vulnerability_reporting/vulnerability_list.html', context)


@admin_only_except_report
@login_required
def vulnerability_detail(request, slug):
    vulnerability = get_object_or_404(Vulnerability, slug=slug)
    comments = vulnerability.comments.all().order_by('-created_at')
    reviews = vulnerability.reviews.all().order_by('-reviewed_at')
    if request.method == 'POST':
        comment_form = VulnerabilityCommentForm(request.POST)
        if comment_form.is_valid():
            comment = comment_form.save(commit=False)
            comment.vulnerability = vulnerability
            comment.user = request.user
            comment.save()
            messages.success(request, 'Comment added successfully.')
            return redirect('exploits:vulnerability_detail', slug=vulnerability.slug)
        else:
            messages.error(request, 'Please correct the errors below.')
    else:
        comment_form = VulnerabilityCommentForm()

    context = {
        'vulnerability': vulnerability,
        'comments': comments,
        'comment_form': comment_form,
        'reviews': reviews,
    }
    return render(request, 'vulnerability_reporting/vulnerability_detail.html', context)


@admin_only_except_report
@login_required
def delete_vulnerability(request, slug):
    vulnerability = get_object_or_404(Vulnerability, slug=slug)
    if request.method == 'POST':
        if request.user == vulnerability.reported_by or request.user.is_staff:
            vulnerability.delete()
            messages.success(request, 'Vulnerability report deleted successfully.')
            return redirect('exploits:vulnerability_list')
        else:
            messages.error(request, 'You do not have permission to delete this vulnerability.')
    return render(request, 'vulnerability_reporting/confirm_delete.html', {'vulnerability': vulnerability})


@admin_only_except_report
def update_review_status(request, review_id):
    review = get_object_or_404(Review, id=review_id)
    if request.method == 'POST':
        status = request.POST.get('status')
        if status in dict(Review.REVIEW_STATUS_CHOICES).keys():
            review.status = status
            review.save()
            messages.success(request, 'Review status updated successfully.')
        else:
            messages.error(request, 'Invalid status choice.')
    return redirect('exploits:vulnerability_detail', slug=review.vulnerability.slug)


@admin_only_except_report
def dashboard(request):
    vulnerabilities = Vulnerability.objects.all()

    # Calculate counts
    total_reports = vulnerabilities.count()
    open_reports = vulnerabilities.exclude(status='resolved').count()
    closed_reports = vulnerabilities.filter(status='resolved').count()
    critical_reports = vulnerabilities.filter(severity='critical').count()

    # Calculate vulnerability trends (last 30 days)
    thirty_days_ago = timezone.now() - timedelta(days=30)
    trends = vulnerabilities.filter(reported_at__gte=thirty_days_ago) \
        .annotate(date=TruncDate('reported_at')) \
        .values('date') \
        .annotate(count=Count('id')) \
        .order_by('date')

    trend_dates = [trend['date'].strftime('%Y-%m-%d') for trend in trends]
    trend_counts = [trend['count'] for trend in trends]

    # Calculate severity distribution
    severity_distribution = vulnerabilities.values('severity') \
        .annotate(count=Count('id')) \
        .order_by('severity')
    severity_counts = [0, 0, 0, 0]  # [low, medium, high, critical]
    for item in severity_distribution:
        if item['severity'] == 'low':
            severity_counts[0] = item['count']
        elif item['severity'] == 'medium':
            severity_counts[1] = item['count']
        elif item['severity'] == 'high':
            severity_counts[2] = item['count']
        elif item['severity'] == 'critical':
            severity_counts[3] = item['count']

    recent_vulnerabilities = vulnerabilities.order_by('-reported_at')[:10]

    # Modified: Only show users who have reported vulnerabilities
    reporters = User.objects.annotate(report_count=Count('reported_vulnerabilities')) \
                    .filter(report_count__gt=0) \
                    .order_by('-report_count')[:5]

    # New feature: Average time to resolution
    now = timezone.now()
    resolved_vulnerabilities = vulnerabilities.filter(status='resolved')
    avg_resolution_time = resolved_vulnerabilities.aggregate(
        avg_time=Avg(now - F('reported_at'))
    )['avg_time']

    if avg_resolution_time:
        avg_resolution_days = avg_resolution_time.days
    else:
        avg_resolution_days = 0

    context = {
        'total_reports': total_reports,
        'open_reports': open_reports,
        'closed_reports': closed_reports,
        'critical_reports': critical_reports,
        'trend_dates': trend_dates,
        'trend_counts': trend_counts,
        'severity_distribution': severity_counts,
        'recent_vulnerabilities': recent_vulnerabilities,
        'reporters': reporters,
        'avg_resolution_days': avg_resolution_days,  # New context variable
    }
    return render(request, 'vulnerability_reporting/dashboard.html', context)

@admin_only_except_report
def api_vulnerabilities(request):
    sort = request.GET.get('sort', 'date')
    start_date = request.GET.get('start')
    end_date = request.GET.get('end')

    vulnerabilities = Vulnerability.objects.all()

    if start_date and end_date:
        vulnerabilities = vulnerabilities.filter(reported_at__range=[start_date, end_date])

    if sort == 'date':
        vulnerabilities = vulnerabilities.order_by('-reported_at')
    elif sort == 'title':
        vulnerabilities = vulnerabilities.order_by('title')
    elif sort == 'severity':
        vulnerabilities = vulnerabilities.order_by('-severity')
    elif sort == 'status':
        vulnerabilities = vulnerabilities.order_by('status')
    elif sort == 'reporter':
        vulnerabilities = vulnerabilities.order_by('reported_by__username')

    data = [{
        'title': v.title,
        'severity': v.get_severity_display(),
        'status': v.get_status_display(),
        'reported_by': v.reported_by.username if v.reported_by else 'Anonymous',
        'reported_at': v.reported_at.strftime('%Y-%m-%d %H:%M'),
        'slug': v.slug
    } for v in vulnerabilities[:10]]  # Limit to 10 results for performance

    return JsonResponse(data, safe=False)

# def dashboard(request):
#     if not request.user.is_authenticated or not request.user.is_staff:
#         # Render the specific 404 template from the vulnerability reporting app
#         return HttpResponseNotFound(render(request, 'vulnerability_reporting/404.html', status=404))
#
#     vulnerabilities = Vulnerability.objects.all()
#     total_new_requests = vulnerabilities.filter(status='pending').count()
#     total_assigned = vulnerabilities.filter(status='assigned').count()
#     total_investigation = vulnerabilities.filter(status='investigation_in_progress').count()
#     total_fix_in_progress = vulnerabilities.filter(status='fix_in_progress').count()
#     total_resolved = vulnerabilities.filter(status='resolved').count()
#     total_reports = vulnerabilities.count()
#
#     recent_vulnerabilities = vulnerabilities.order_by('-reported_at')[:5]
#
#     reporters = User.objects.annotate(report_count=Count('reported_vulnerabilities')).order_by('-report_count')[:5]
#
#     context = {
#         'total_new_requests': total_new_requests,
#         'total_assigned': total_assigned,
#         'total_investigation': total_investigation,
#         'total_fix_in_progress': total_fix_in_progress,
#         'total_resolved': total_resolved,
#         'total_reports': total_reports,
#         'recent_vulnerabilities': recent_vulnerabilities,
#         'reporters': reporters,
#     }
#     return render(request, 'vulnerability_reporting/dashboard.html', context)


@admin_only_except_report
def update_vulnerability_status(request, slug):
    vulnerability = get_object_or_404(Vulnerability, slug=slug)
    if request.method == 'POST':
        new_status = request.POST.get('status')
        remarks = request.POST.get('remarks')

        if new_status in dict(Vulnerability.STATUS_CHOICES).keys():
            vulnerability.status = new_status
            vulnerability.save()

            messages.success(request, 'Vulnerability status updated successfully.')
        else:
            messages.error(request, 'Invalid status choice.')
    return redirect('exploits:vulnerability_detail', slug=slug)



@admin_only_except_report
def user_vulnerabilities(request):
    vulnerabilities = Vulnerability.objects.filter(reported_by=request.user).order_by('-reported_at')
    paginator = Paginator(vulnerabilities, 10)  # Show 10 vulnerabilities per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    return render(request, 'vulnerability_reporting/user_vulnerabilities.html', {'page_obj': page_obj})


def admin_check(user):
    return user.is_authenticated and user.is_staff

@user_passes_test(admin_check, login_url=None)
def search_vulnerabilities(request):
    if not request.user.is_staff:
        raise Http404

    query = request.GET.get('q', '')
    vulnerabilities = Vulnerability.objects.all()

    if query:
        vulnerabilities = vulnerabilities.filter(
            Q(title__icontains=query) |
            Q(description__icontains=query) |
            Q(affected_components__icontains=query)
        )

    total_results = vulnerabilities.count()
    paginator = Paginator(vulnerabilities, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'query': query,
        'total_results': total_results,
        'is_admin': True,
    }

    return render(request, 'vulnerability_reporting/search_results.html', context)

@admin_only_except_report
@login_required
def export_vulnerabilities(request):
    if request.method == 'POST':
        form = ExportRequestForm(request.POST)
        if form.is_valid():
            start_date = form.cleaned_data['start_date']
            end_date = form.cleaned_data['end_date']

            vulnerabilities = Vulnerability.objects.filter(
                reported_at__range=[start_date, end_date]
            ).order_by('-reported_at')

            return export_html(vulnerabilities, start_date, end_date)
    else:
        form = ExportRequestForm()

    return render(request, 'vulnerability_reporting/export_vulnerability.html', {'form': form})


def export_html(vulnerabilities, start_date, end_date):
    context = {
        'vulnerabilities': vulnerabilities,
        'start_date': start_date,
        'end_date': end_date,
        'now': timezone.now(),
    }
    html_content = render_to_string('vulnerability_reporting/export_template.html', context)

    response = HttpResponse(html_content, content_type='text/html')
    filename = f"vulnerabilities_{start_date.strftime('%Y%m%d')}_{end_date.strftime('%Y%m%d')}.html"
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    return response

def handler404(request, exception):
    return render(request, 'vulnerability_reporting/404.html', status=404)


def handler500(request):
    return render(request, 'vulnerability_reporting/500.html', status=500)